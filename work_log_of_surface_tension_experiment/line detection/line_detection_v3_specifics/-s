<p>line detector v3 works via fitting a line pattern around every pixel. in the first attempt I use two patterns, x oriented and y oriented, the results are:</p><table><tbody><tr class="odd"><td style="text-align: center;"><img src="line_detector_v3_1.png" /></td></tr><tr class="even"><td style="text-align: center;"><img src="line_detector_v3_3.png" /></td></tr><tr class="odd"><td style="text-align: center;"><img src="line_detector_v3_5.png" /></td></tr></tbody></table><h1 id="v3.1">v3.1</h1><p>because I sum the real and imaginary parts, a line’s end point gets double, which is bad, so in v3.1 I add take the maximum of the real and the imaginary, instead of the sum:</p><table><tbody><tr class="odd"><td style="text-align: center;"><img src="line_detector_v3.1_line_end.png" /></td><td style="text-align: center;"><img src="line_detector_v3_line_end.png" /></td></tr></tbody></table><table><tbody><tr class="odd"><td style="text-align: center;">table of results of line detector v3.1 when applied to a test pattern</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">line width = 1</th><th style="text-align: center;">line width = 4</th><th style="text-align: center;">line width = 7</th><th style="text-align: center;">line width = 10</th><th style="text-align: center;">line width = 13</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">void width = 10</td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=01.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=04.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=07.png" /></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: left;">void width = 20</td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=01.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=04.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=07.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=10.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=13.png" /></td></tr><tr class="odd"><td style="text-align: left;">void width = 30</td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=01.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=04.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=07.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=10.png" /></td><td style="text-align: center;"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=13.png" /></td></tr></tbody></table><p>it can be seen that the performance is optimal when void width = (line width+1)*2. now, I want to compose some smooth function that will inherently hold this relation [void width = (line width+1)*2], and thus have only one major parameter.</p><h1 id="v3.2">v3.2</h1><p>i ended up making line-detector v3.2 which uses the second derivative of a Gaussian filter, this is faster due to me using an elementary function called scipy.ndimage.gaussian_filter. <strong>but this ended up lowering the performance, so Obviously I wont be using it.</strong></p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">version 3.1</th><th style="text-align: center;">version 3.2</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">line width = 1</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=01.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=01.png" /></td></tr><tr class="even"><td style="text-align: left;">line width = 2</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=02.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=02.png" /></td></tr><tr class="odd"><td style="text-align: left;">line width = 3</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=03.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=03.png" /></td></tr><tr class="even"><td style="text-align: left;">line width = 4</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=04.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=04.png" /></td></tr><tr class="odd"><td style="text-align: left;">line width = 5</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=05.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=05.png" /></td></tr><tr class="even"><td style="text-align: left;">line width = 6</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=06.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=06.png" /></td></tr><tr class="odd"><td style="text-align: left;">line width = 7</td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=07.png" /></td><td style="text-align: center;"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=07.png" /></td></tr></tbody></table><h1 id="v3.3">v3.3</h1><p>v3.3 is based on v3.1 except I stop using complex numbers, and added diagonals.</p><p><img src="line%20detection%20v3.3%20fit%20kernels.png" /></p><table><tbody><tr class="odd"><td style="text-align: center;"><img src="line%20detection%20v3.3%20split%20kernels.png" /></td><td style="text-align: center;"><img src="line%20detection%20v3.3%20split%20kernels%20vmin=0.png" /></td></tr></tbody></table><p>the following problem arose, the diagonal kernels slightly negatively detect diagonal lines that are orthogonal to them. this is because the parpandicular diagonals sum up to not 1, as the following figure shows <img src="demonstration%20of%20v3.3%20normalisation%20problem.png" /> the solution is to normalise, in such a way that all perpandicular diagonals sum up to zero.</p><h1 id="v3.4">v3.4</h1><p><img src="line%20detection%20v3.4%20fit%20kernels.png" /> <img src="line%20detection%20v3.4%20split%20kernels%20vmin=0.png" /> this apparently fixed the problem, but has reduced line detection performance. this is not surprising as we found that sharp edges only improve performance. a possible solution is use the rotation functions automatic ability to black out the corners, and resize the image.</p><h1 id="v3.5">v3.5</h1><p><img src="line%20detection%20v3.5%20fit%20kernels.png" /> notice the diagonal kernels are bigger. I will note that the diagonal kernels are normalized, so they add up to zero, this was slightly tricky to do:</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># normalise diag1_kernel</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rot_mask <span class="op">=</span> rotate(x_ker<span class="op">*</span><span class="dv">0</span><span class="op">+</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">45</span>,reshape<span class="op">=</span><span class="va">True</span>,order<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>diag1_ker <span class="op">-=</span> np.<span class="bu">sum</span>(diag1_ker)<span class="op">/</span>np.<span class="bu">sum</span>(rot_mask)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>diag1_ker <span class="op">*=</span> rot_mask</span></code></pre></div><p>the resulting line detection is: <img src="line%20detection%20v3.5%20split%20kernels%20vmin=0.png" /> <img src="line%20detection%20v3.5.png" /> this is definitely a great improvement</p><h1 id="v3.6">v3.6</h1><p>small change to how the different colors sum up, used to sum the square of the detection score for each color, in v3.6 I remove the square.</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">### v3.5 </span><span class="al">###</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>fit_value_magnitude <span class="op">=</span> np.<span class="bu">sum</span>(fit_value<span class="op">**</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> fit_value_magnitude</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">### v3.6 </span><span class="al">###</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>fit_value_magnitude <span class="op">=</span> np.<span class="bu">sum</span>(fit_value,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> fit_value_magnitude</span></code></pre></div><p><img src="line%20detection%20v3.6.png" /> <img src="line%20detection%20v3.6_zoom1.jpg" /> <img src="line%20detection%20v3.6_zoom2.jpg" /> after this change we get a more even result for some reason, or an other way to say this is that somewhat unsurprisingly squaring the line detector result for each color before adding them up makes the resulting scores-image uneven, less predictable, and frankly worse:</p><p>comparison of images :</p><table><thead><tr class="header"><th style="text-align: center;"><img src="line%20detection%20v3.5%20with%20color_location_scores.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">ColorScore\_v1(M)∗LocationScore\_v2(M)∗LineDetectorScore\_v3.5(M)</span></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><img src="line%20detection%20v3.6%20with%20color_location_scores.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em><span class="math inline">ColorScore\_v1(M)∗LocationScore\_v2(M)∗LineDetectorScore\_v3.6(M)</span></em></td></tr></tbody></table><h1 id="v3.7">v3.7</h1><p>made this after making v4.1, only difference is that I add the std and orginatory stuff that I put in v4.1, do difference in performance.</p><p>line detector v3 works via fitting a line pattern around every pixel. in the first attempt I use two patterns, x oriented and y oriented, the results are:</p><table><tbody><tr class="odd"><td style="text-align: center;"><a href="line_detector_v3_1.png" target="_blank"><img src="line_detector_v3_1.png" /></a></td></tr><tr class="even"><td style="text-align: center;"><a href="line_detector_v3_3.png" target="_blank"><img src="line_detector_v3_3.png" /></a></td></tr><tr class="odd"><td style="text-align: center;"><a href="line_detector_v3_5.png" target="_blank"><img src="line_detector_v3_5.png" /></a></td></tr></tbody></table><h1 id="v3.1">v3.1</h1><p>because I sum the real and imaginary parts, a line’s end point gets double, which is bad, so in v3.1 I add take the maximum of the real and the imaginary, instead of the sum:</p><table><tbody><tr class="odd"><td style="text-align: center;"><a href="line_detector_v3.1_line_end.png" target="_blank"><img src="line_detector_v3.1_line_end.png" /></a></td><td style="text-align: center;"><a href="line_detector_v3_line_end.png" target="_blank"><img src="line_detector_v3_line_end.png" /></a></td></tr></tbody></table><table><tbody><tr class="odd"><td style="text-align: center;">table of results of line detector v3.1 when applied to a test pattern</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">line width = 1</th><th style="text-align: center;">line width = 4</th><th style="text-align: center;">line width = 7</th><th style="text-align: center;">line width = 10</th><th style="text-align: center;">line width = 13</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">void width = 10</td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=01.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=01.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=04.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=04.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=07.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=10-linewidth=07.png" /></a></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: left;">void width = 20</td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=01.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=01.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=04.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=04.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=07.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=07.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=10.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=10.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=13.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=20-linewidth=13.png" /></a></td></tr><tr class="odd"><td style="text-align: left;">void width = 30</td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=01.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=01.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=04.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=04.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=07.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=07.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=10.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=10.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=13.png" target="_blank"><img src="line_detection_v3p1_on_pattern_2/line_detection_on_pattern2-voidwidth=30-linewidth=13.png" /></a></td></tr></tbody></table><p>it can be seen that the performance is optimal when void width = (line width+1)*2. now, I want to compose some smooth function that will inherently hold this relation [void width = (line width+1)*2], and thus have only one major parameter.</p><h1 id="v3.2">v3.2</h1><p>i ended up making line-detector v3.2 which uses the second derivative of a Gaussian filter, this is faster due to me using an elementary function called scipy.ndimage.gaussian_filter. <strong>but this ended up lowering the performance, so Obviously I wont be using it.</strong></p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">version 3.1</th><th style="text-align: center;">version 3.2</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">line width = 1</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=01.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=01.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=01.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=01.png" /></a></td></tr><tr class="even"><td style="text-align: left;">line width = 2</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=02.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=02.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=02.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=02.png" /></a></td></tr><tr class="odd"><td style="text-align: left;">line width = 3</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=03.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=03.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=03.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=03.png" /></a></td></tr><tr class="even"><td style="text-align: left;">line width = 4</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=04.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=04.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=04.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=04.png" /></a></td></tr><tr class="odd"><td style="text-align: left;">line width = 5</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=05.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=05.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=05.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=05.png" /></a></td></tr><tr class="even"><td style="text-align: left;">line width = 6</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=06.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=06.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=06.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=06.png" /></a></td></tr><tr class="odd"><td style="text-align: left;">line width = 7</td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=07.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p1_on_pattern2-linewidth=07.png" /></a></td><td style="text-align: center;"><a href="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=07.png" target="_blank"><img src="line_detection_v3p2_on_pattern_2/line_detection_v3p2_on_pattern2-linewidth=07.png" /></a></td></tr></tbody></table><h1 id="v3.3">v3.3</h1><p>v3.3 is based on v3.1 except I stop using complex numbers, and added diagonals.</p><p><a href="line%20detection%20v3.3%20fit%20kernels.png" target="_blank"><img src="line%20detection%20v3.3%20fit%20kernels.png" /></a></p><table><tbody><tr class="odd"><td style="text-align: center;"><a href="line%20detection%20v3.3%20split%20kernels.png" target="_blank"><img src="line%20detection%20v3.3%20split%20kernels.png" /></a></td><td style="text-align: center;"><a href="line%20detection%20v3.3%20split%20kernels%20vmin=0.png" target="_blank"><img src="line%20detection%20v3.3%20split%20kernels%20vmin=0.png" /></a></td></tr></tbody></table><p>the following problem arose, the diagonal kernels slightly negatively detect diagonal lines that are orthogonal to them. this is because the parpandicular diagonals sum up to not 1, as the following figure shows <a href="demonstration%20of%20v3.3%20normalisation%20problem.png" target="_blank"><img src="demonstration%20of%20v3.3%20normalisation%20problem.png" /></a> the solution is to normalise, in such a way that all perpandicular diagonals sum up to zero.</p><h1 id="v3.4">v3.4</h1><p><a href="line%20detection%20v3.4%20fit%20kernels.png" target="_blank"><img src="line%20detection%20v3.4%20fit%20kernels.png" /></a> <a href="line%20detection%20v3.4%20split%20kernels%20vmin=0.png" target="_blank"><img src="line%20detection%20v3.4%20split%20kernels%20vmin=0.png" /></a> this apparently fixed the problem, but has reduced line detection performance. this is not surprising as we found that sharp edges only improve performance. a possible solution is use the rotation functions automatic ability to black out the corners, and resize the image.</p><h1 id="v3.5">v3.5</h1><p><a href="line%20detection%20v3.5%20fit%20kernels.png" target="_blank"><img src="line%20detection%20v3.5%20fit%20kernels.png" /></a> notice the diagonal kernels are bigger. I will note that the diagonal kernels are normalized, so they add up to zero, this was slightly tricky to do:</p><div id="cb1" class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>
<span class="co"># normalise diag1_kernel</span>
</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>
rot_mask <span class="op">=</span>
 rotate(x_ker<span class="op">*</span>
<span class="dv">0</span>
<span class="op">+</span>
<span class="dv">1</span>
,<span class="op">-</span>
<span class="dv">45</span>
,reshape<span class="op">=</span>
<span class="va">True</span>
,order<span class="op">=</span>
<span class="dv">1</span>
)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>
diag1_ker <span class="op">-=</span>
 np.<span class="bu">sum</span>
(diag1_ker)<span class="op">/</span>
np.<span class="bu">sum</span>
(rot_mask)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>
diag1_ker <span class="op">*=</span>
 rot_mask</span>
</code>
</pre></div><p>the resulting line detection is: <a href="line%20detection%20v3.5%20split%20kernels%20vmin=0.png" target="_blank"><img src="line%20detection%20v3.5%20split%20kernels%20vmin=0.png" /></a> <a href="line%20detection%20v3.5.png" target="_blank"><img src="line%20detection%20v3.5.png" /></a> this is definitely a great improvement</p><h1 id="v3.6">v3.6</h1><p>small change to how the different colors sum up, used to sum the square of the detection score for each color, in v3.6 I remove the square.</p><div id="cb2" class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>
<span class="co">### v3.5 </span>
<span class="al">###</span>
</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>
fit_value_magnitude <span class="op">=</span>
 np.<span class="bu">sum</span>
(fit_value<span class="op">**</span>
<span class="dv">2</span>
,<span class="op">-</span>
<span class="dv">1</span>
)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>
<span class="cf">return</span>
 fit_value_magnitude</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>
<span class="co">### v3.6 </span>
<span class="al">###</span>
</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>
fit_value_magnitude <span class="op">=</span>
 np.<span class="bu">sum</span>
(fit_value,<span class="op">-</span>
<span class="dv">1</span>
)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>
<span class="cf">return</span>
 fit_value_magnitude</span>
</code>
</pre></div><p><a href="line%20detection%20v3.6.png" target="_blank"><img src="line%20detection%20v3.6.png" /></a> <a href="line%20detection%20v3.6_zoom1.jpg" target="_blank"><img src="line%20detection%20v3.6_zoom1.jpg" /></a> <a href="line%20detection%20v3.6_zoom2.jpg" target="_blank"><img src="line%20detection%20v3.6_zoom2.jpg" /></a> after this change we get a more even result for some reason, or an other way to say this is that somewhat unsurprisingly squaring the line detector result for each color before adding them up makes the resulting scores-image uneven, less predictable, and frankly worse:</p><p>comparison of images :</p><table><thead><tr class="header"><th style="text-align: center;"><a href="line%20detection%20v3.5%20with%20color_location_scores.png" target="_blank"><img src="line%20detection%20v3.5%20with%20color_location_scores.png" /></a></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">ColorScore_v1(M)∗LocationScore_v2(M)∗LineDetectorScore_v3.5(M)</span></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><a href="line%20detection%20v3.6%20with%20color_location_scores.png" target="_blank"><img src="line%20detection%20v3.6%20with%20color_location_scores.png" /></a></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em><span class="math inline">ColorScore_v1(M)∗LocationScore_v2(M)∗LineDetectorScore_v3.6(M)</span> </em></td></tr></tbody></table><h1 id="v3.7">v3.7</h1><p>made this after making v4.1, only difference is that I add the std and orginatory stuff that I put in v4.1, do difference in performance.</p>
